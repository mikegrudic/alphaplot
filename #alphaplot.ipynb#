{
 "cells": [
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 5,
=====
   "execution_count": 178,
>>>>>>> 3ec6318 (stuff)
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Using matplotlib backend: TkAgg\n",
      "Populating the interactive namespace from numpy and matplotlib\n"
     ]
    }
   ],
   "source": [
    "import matplotlib\n",
    "#matplotlib.use('pgf')\n",
    "#matplotlib.rcParams['pgf.preamble'] = [r'\\usepackage{url}', ]\n",
    "%pylab\n",
    "from pandas import read_csv\n",
    "import webbrowser\n",
    "import pandas as pd\n",
    "\n",
    "plot_points_without_errors = True\n",
    "color_quantity = \"Year\"\n",
    "colormap = \"viridis\"\n",
    "marker_by_type = True\n",
    "mmin = 0.01\n",
    "\n",
    "if marker_by_type:\n",
    "    markerdict = {\"OB Association\": \"d\", \"Young Cluster\": \"o\", \"MW Field\": \">\", \"MW Bulge\": \"v\",\"Globular Cluster\": \"X\", \"MW Nuclear Cluster\": \"^\"}\n",
    "\n",
    "data = read_csv(\"alphaplot.csv\",skip_blank_lines=True)\n",
    "data = data[~np.isnan(data[\"Slope (Salpeter=2.35)\"])]\n",
    "\n",
    "references = data[\"Reference\"]\n",
    "system = data[\"System\"]\n",
    "Z = data[\"Metallicity [Z/H]\"]\n",
    "#cut = (system==\"ONC\") #(Z<=-0.5) #np.ones(len(data),dtype=np.bool) #(system==\"ONC\")#*(year <= 2003)\n",
    "#cut = np.ones(len(data))\n",
    "#data = data[cut]\n",
    "references = data[\"Reference\"]\n",
    "types = data[\"Class\"]\n",
    "markers = np.array([markerdict[t] for t in types])\n",
    "year = np.array([int(r[:4]) if type(r)==str else -1 for r in references])\n",
    "slope = -data[\"Slope (Salpeter=2.35)\"]+1\n",
    "slope += np.random.normal(size=(len(slope),))*0.02\n",
    "mlow = data[\"Lower mass (Msun)\"]\n",
    "mhi = data[\"Upper mass (Msun)\"]\n",
    "mmed = (mlow*mhi)**0.5\n",
    "slope_error = data[\"Slope uncertainty\"]\n",
    "slope_upper = -data[\"Upper limit (1 sigma)\"]+1\n",
    "slope_lower = -data[\"Lower limit (1 sigma)\"]+1"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 10,
=======
   "execution_count": 185,
>>>>>>> 3ec6318 (stuff)
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
<<<<<<< HEAD
      "[[55.18151865 -0.87862692]\n",
      " [ 7.07106781 -1.41153209]\n",
      " [ 2.82842712 -0.71486682]\n",
      " [ 0.34741906  0.14643331]\n",
      " [ 0.99699549 -1.14371681]\n",
      " [ 0.93166518 -1.16061704]\n",
      " [ 0.30626786  0.11011629]\n",
      " [ 0.968504   -1.00152968]\n",
      " [14.14213562 -0.67494471]\n",
      " [ 1.09544512 -0.98802139]\n",
      " [ 7.90569415 -1.44103138]]\n"
=======
      "[[55.18151865 -0.90458989]\n",
      " [ 7.07106781 -1.4458226 ]\n",
      " [ 2.82842712 -0.75613715]\n",
      " [ 0.34741906  0.1230021 ]\n",
      " [ 0.99699549 -1.14883843]\n",
      " [ 0.93166518 -1.16608392]\n",
      " [ 0.30626786  0.12183085]\n",
      " [ 0.968504   -0.99692071]\n",
      " [14.14213562 -0.67957   ]\n",
      " [ 1.09544512 -1.00508916]\n",
      " [ 7.90569415 -1.42404196]]\n"
>>>>>>> 3ec6318 (stuff)
     ]
    }
   ],
   "source": [
    "\n",
    "fig, ax = plt.subplots(1,1,figsize=(6,3))\n",
    "\n",
    "if color_quantity==\"Year\":\n",
    "    colors = plt.get_cmap(colormap)((year-year.min()).clip(0,1e100)/(year-year.min()).max())\n",
    "elif color_quantity==\"Metallicity\":\n",
    "    colors = plt.get_cmap(colormap)((Z-Z.min())/(Z.max()-Z.min()))\n",
    "else:\n",
    "    colors=np.zeros((len(data),3))\n",
    "\n",
    "\n",
    "ebar_lw = 0.3 # linewidth of errorbars\n",
    "# first plot asymmetric errors where available\n",
    "i = np.isfinite(slope_lower) * np.isfinite(slope_upper)\n",
    "ax.errorbar(mmed[i],slope[i],xerr=[mmed[i]-mlow[i],mhi[i]-mmed[i]], yerr=[np.abs(slope-slope_lower)[i],np.abs(slope_upper-slope)[i]], ls='',capsize=0,lw=ebar_lw,c='black',marker=None,ecolor='grey')\n",
    "print(np.c_[mmed[i],slope[i]])\n",
    "for m in np.unique(markers):\n",
<<<<<<< HEAD
    "    ax.scatter(mmed[i*(markers==m)],slope[i*(markers==m)],c=colors[i*(markers==m)],s=10,zorder=20,marker=m,lw=0) #xerr=[mmed[i]-mlow[i],mhi[i]-mmed[i]], yerr=[(slope-slope_lower)[i],(slope_upper-slope)[i]], ls='',capsize=0,lw=0.5,c='black',marker='o',markersize=1)\n",
=======
    "    ax.scatter(mmed[i*(markers==m)],slope[i*(markers==m)],c=colors[i*(markers==m)],s=4,zorder=20,marker=m,edgecolors='none') #xerr=[mmed[i]-mlow[i],mhi[i]-mmed[i]], yerr=[(slope-slope_lower)[i],(slope_upper-slope)[i]], ls='',capsize=0,lw=0.5,c='black',marker='o',markersize=1)\n",
>>>>>>> 3ec6318 (stuff)
    "\n",
    "# now symmetric errors\n",
    "i = np.isfinite(slope_error)# * np.isfinite(slope_upper)\n",
    "ax.errorbar(mmed[i],slope[i],xerr=[mmed[i]-mlow[i],mhi[i]-mmed[i]], yerr=slope_error[i], ls='',capsize=0,lw=ebar_lw,c='black',marker=None,markersize=0,ecolor='grey')\n",
    "for m in np.unique(markers):\n",
<<<<<<< HEAD
    "    ax.scatter(mmed[i*(markers==m)],slope[i*(markers==m)],c=colors[i*(markers==m)],s=10,zorder=10,marker=m,lw=0)\n",
=======
    "    ax.scatter(mmed[i*(markers==m)],slope[i*(markers==m)],c=colors[i*(markers==m)],s=4,zorder=10,marker=m,edgecolors='none')\n",
>>>>>>> 3ec6318 (stuff)
    "\n",
    "# and now ones without any errorbars :(\n",
    "if plot_points_without_errors:\n",
    "    i = np.isnan(slope_error)\n",
    "    ax.errorbar(mmed[i],slope[i],xerr=[mmed[i]-mlow[i],mhi[i]-mmed[i]], ls='',capsize=0,lw=ebar_lw,color='black',marker='o',markersize=0,ecolor='grey')\n",
    "    \n",
    "    for m in np.unique(markers):\n",
<<<<<<< HEAD
    "        ax.scatter(mmed[i*(markers==m)],slope[i*(markers==m)],c=colors[i*(markers==m)],s=10,zorder=2,marker=m,lw=0)\n",
=======
    "        ax.scatter(mmed[i*(markers==m)],slope[i*(markers==m)],c=colors[i*(markers==m)],s=4,zorder=2,marker=m,edgecolors='none')\n",
>>>>>>> 3ec6318 (stuff)
    "\n",
    "\n",
    "#colorbar\n",
    "if color_quantity==\"Year\":\n",
    "    import matplotlib.ticker as ticker\n",
    "    def fmt(x, pos):\n",
    "        a, b = '{:.2e}'.format(x).split('e')\n",
    "        b = int(b)\n",
    "        return r'%d'%int(x)\n",
    "\n",
    "    sc = ax.scatter(np.zeros(len(mmed)+1),-100*np.ones(len(mmed)+1),c=np.int_(list(year)+[year.min()]),s=10,cmap=colormap)\n",
    "    plt.colorbar(sc,format=ticker.FuncFormatter(fmt),pad=0,label=\"Year\")\n",
    "elif color_quantity==\"Metallicity\":\n",
    "    sc = ax.scatter(np.zeros(len(mmed)),-100*np.ones(len(mmed)),c=Z,s=10,cmap=colormap)\n",
    "    plt.colorbar(sc,label=\"Z\",pad=0)\n",
    "\n",
    "\n",
    "if len(np.unique(data[\"System\"].values))==1: \n",
    "    ax.set_title(data[\"System\"][0])\n",
    "\n",
    "# plot dummy points for URLS\n",
    "# df = pd.DataFrame({'x': mmed,\n",
    "#                    'y': slope,\n",
    "#                    'link': [r\"https://ui.adsabs.harvard.edu/abs/\"+r for r in references]})\n",
    "\n",
    "# def on_pick(event):\n",
    "#     url = df.link.iloc[event.ind[0]]\n",
    "#     webbrowser.open_new_tab(url)\n",
    "\n",
    "# ax.scatter(x=df.x, y=df.y,picker=5,s=1,alpha=0)\n",
    "\n",
    "urls = [r\"https://ui.adsabs.harvard.edu/abs/\"+r.split(\";\")[0] for r in references]\n",
    "# import matplotlib.patches as patches\n",
    "sc = ax.scatter(mmed,slope,alpha=1e-6,zorder=10000)\n",
    "sc.set_urls(urls)\n",
    "for x,y,u in zip(mmed,slope,urls):\n",
    "    txt = ax.text(x, y, \"o\", url=u, alpha=1e-6, fontsize=3,bbox=dict(boxstyle='circle',url=u,alpha=1e-6),ha='center',va='center',zorder=10000) #bbox = dict(color='w', alpha=0.01, url=u)\n",
    "    #ax.add_patch(patches.Rectangle((x,y),0.1,0.1,url=u))#, url=u, alpha=1e-6, fontsize=3,bbox=dict(boxstyle='circle',url=u,alpha=1e-6),ha='center',va='center',zorder=10000)\n",
    "\n",
    "peak_pos = 0.2\n",
    "ax.plot([mmin,300],[0,0],color='black',zorder=-1000,lw=0.5,ls='solid')\n",
<<<<<<< HEAD
    "ax.fill_between([0.1,0.3],[-0.3,-0.3],[0.3,0.3],color='purple',zorder=-1000,alpha=0.3,label=\"Typical Peak/Plateau\",linewidth=0)\n",
=======
    "ax.fill_between([0.1,0.3],[-0.4,-0.4],[0.4,0.4],color='purple',zorder=-1000,alpha=0.3,label=\"Typical Peak/Plateau\",linewidth=0)\n",
>>>>>>> 3ec6318 (stuff)
    "#ax.plot([0.2,0.2],[-10,10],ls='dashed',color='grey',zorder=-1000,lw=0.5)\n",
    "#ax.text(0.0045,-0.2,'Peak/Plateau',color='black',fontsize=6)\n",
    "#ax.text(0.0045,0.4,'$\\sigma$',color='black',fontsize=6)\n",
    "#ax.text(0.0045,-0.6,'$\\sigma$',color='black',fontsize=6)\n",
    "#ax.arrow(0.004,0,0,1,width=0.0001,head_length=0.1,head_width=0.001,length_includes_head=True,facecolor='black',lw=0)\n",
    "#ax.scatter(0.004,0,color='black',s=4)\n",
    "#ax.arrow(0.004,0,0,-1,width=0.0001,head_length=0.1,head_width=0.001,length_includes_head=True,facecolor='black',lw=0)\n",
    "\n",
    "ax.plot([mmin,300],[-1.35,-1.35],ls='-.',color='black',zorder=-1000,lw=0.5)\n",
    "ax.text(mmin*2.2,-1.55,\"Salpeter Slope (-1.35)\",color='black',fontsize=6)\n",
    "# ax.plot([mmin,300],[-1.,-1.],ls='dotted',color='grey',zorder=-1000,lw=0.5,label=\"Log-normal $\\pm \\sigma$\")\n",
    "# ax.plot([mmin,300],[1.,1.],ls='dotted',color='grey',zorder=-1000,lw=0.5)\n",
    "# ax.plot([0.099,0.099],[-10.,10.],ls='dotted',color='grey',zorder=-1000,lw=0.5)\n",
    "# ax.plot([0.7096,0.7096],[-10.,10.],ls='dotted',color='grey',zorder=-1000,lw=0.5)\n",
    "\n",
    "mgrid = np.logspace(-3,3,1000)\n",
    "\n",
    "def analytic_imf_slope(mgrid,model=\"Chabrier (2005)\"):\n",
    "    slope = np.zeros_like(mgrid)\n",
    "    if \"Chabrier\" in model:\n",
    "        if \"2005\" in model: \n",
    "            logmc = np.log10(0.2) # \n",
    "            sigma = 0.55\n",
    "        else:\n",
    "            logmc = np.log10(0.08)\n",
    "            sigma = 0.69\n",
    "        slope = -(np.log10(mgrid)-logmc)/(sigma**2) / np.e\n",
    "        slope[mgrid>1] = -1.35\n",
    "    elif \"Kroupa\" in model:\n",
    "        slope[mgrid<0.08] = 0.7\n",
    "        if \"2002\" in model:\n",
    "            slope[(mgrid>0.08)*(mgrid<0.5)] = -0.3\n",
    "            slope[mgrid>0.5] = -1.3\n",
    "        elif \"2001\" in model:\n",
    "            slope[(mgrid>0.08)*(mgrid<0.5)] = -0.8\n",
    "            slope[(mgrid>0.5)*(mgrid<1)] = -1.7\n",
    "            slope[mgrid>1] = -1.3\n",
    "    \n",
    "    slope[mgrid>120] = np.nan\n",
    "    slope[mgrid<0.01] = np.nan\n",
    "\n",
    "    return slope\n",
    "\n",
    "modelcolors = \"red\", \"darkblue\"\n",
    "models = \"Kroupa (2002)\",\"Chabrier (2005)\"\n",
    "for c, model in zip(modelcolors,models):\n",
    "    slope_model = analytic_imf_slope(mgrid,model)\n",
    "    ax.plot(mgrid,slope_model,zorder=-1000,label=model,color=c)\n",
    "\n",
    "\n",
    "for t, m in markerdict.items():\n",
<<<<<<< HEAD
    "    plt.scatter([-10,-10],[-10,-10],marker=m,lw=0,color='black',label=t,s=10)\n",
    "\n",
    "ax.set(xscale='log',xlabel=r\"Stellar Mass ($M_\\odot$)\", ylabel=r\"IMF Slope $\\Gamma$\",xlim=[mmin,300],ylim=[-3,3.5])\n",
    "ax.legend(fontsize=6,labelspacing=0)\n",
=======
    "    plt.scatter([-10,-10],[-10,-10],marker=m,color='black',label=t,s=4,edgecolors='none')\n",
    "\n",
    "ax.set(xscale='log',xlabel=r\"$M_{\\rm ZAMS}$ ($M_\\odot$)\", ylabel=r\"IMF Slope\",xlim=[mmin,300],ylim=[-3,3.5])\n",
    "ax.legend(fontsize=8,labelspacing=0)\n",
>>>>>>> 3ec6318 (stuff)
    "#fig.canvas.mpl_connect('pick_event', on_pick)\n",
    "plt.savefig(\"IMF_AlphaPlot.pdf\",bbox_inches='tight')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'mgrid' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[1], line 1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m mgrid\n",
      "\u001b[0;31mNameError\u001b[0m: name 'mgrid' is not defined"
     ]
    }
   ],
   "source": [
    "mgrid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 94,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"2005\" in \"Chabrier (2005)\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [],
   "source": [
    "dNdlogm = np.exp(-(np.log10(mgrid))**2/(2*1**2))\n",
    "plt.plot(mgrid, np.gradient(np.log10(dNdlogm))/np.gradient(np.log10(mgrid))); plt.xscale('log')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "interpreter": {
   "hash": "0224a370cf43668979feb4aeca053395e56c41910dc956a688e83b154996b2c5"
  },
  "kernelspec": {
   "display_name": "Python 3.9.13 ('base')",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
